package com.hsbc.trade.transfer.service.impl;

import com.hsbc.trade.ErrorCodes;
import com.hsbc.trade.HTTPRequestHeaderConstants;
import com.hsbc.trade.service.DuplicateSubmitPreventionService;
import com.hsbc.trade.service.RestClientService;
import com.hsbc.trade.transfer.common.*;
import com.hsbc.trade.transfer.constant.TransferQueryParameterConstant;
import com.hsbc.trade.transfer.createtransfer.CreateTransferRequest;
import com.hsbc.trade.transfer.createtransfer.CreateTransferResponse;
import com.hsbc.trade.transfer.createtransfer.TransferOrderInfo;
import com.hsbc.trade.transfer.domain.account.CustomerAccounts;
import com.hsbc.trade.transfer.domain.account.InvestmentAccount;
import com.hsbc.trade.transfer.domain.cep.PartyContactResponse;
import com.hsbc.trade.transfer.domain.cep.PartyNameResponse;
import com.hsbc.trade.transfer.domain.cep.PartyNameResponseName;
import com.hsbc.trade.transfer.domain.mds.GoldPriceResponse;
import com.hsbc.trade.transfer.domain.mds.GoldPriceResponseData;
import com.hsbc.trade.transfer.exception.TransferLimitExceededException;
import com.hsbc.trade.transfer.retrievetransferdetail.RetrieveTransferDetailResponse;
import com.hsbc.trade.transfer.retrievetransferdetail.RetrieveTransferDetailResponseData;
import com.hsbc.trade.transfer.retrievetransferlimit.RetrieveTransferLimitResponse;
import com.hsbc.trade.transfer.retrievetransferlist.RetrieveTransferListResponse;
import com.hsbc.trade.transfer.retrievetransferlist.RetrieveTransferListResponseData;
import com.hsbc.trade.transfer.updatetransfer.UpdateTransferRequest;
import com.hsbc.trade.transfer.updatetransfer.UpdateTransferResponse;
import com.hsbc.trade.utils.E2ETrustTokenUtil;
import jakarta.ws.rs.BadRequestException;
import jakarta.ws.rs.InternalServerErrorException;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.*;
import org.mockito.junit.jupiter.MockitoExtension;
import org.springframework.test.util.ReflectionTestUtils;

import java.math.BigDecimal;
import java.net.URI;
import java.util.*;

import static org.assertj.core.api.Assertions.assertThat;
import static org.junit.jupiter.api.Assertions.*;
import static org.mockito.ArgumentMatchers.*;
import static org.mockito.Mockito.*;

@ExtendWith(MockitoExtension.class)
class TradeTransferServiceImplTest {

    @Mock
    private RestClientService restClientService;

    @Mock
    private E2ETrustTokenUtil e2ETrustTokenUtil;

    @Mock
    private DuplicateSubmitPreventionService duplicateSubmitPreventionService;

    @Mock
    private TradeLimitServiceImpl tradeLimitService;

    @Mock
    private SreValidationServiceImpl sreValidationService;

    @InjectMocks
    private TradeTransferServiceImpl tradeTransferService;

    private Map<String, String> headers;

    @BeforeEach
    void setUp() {
        MockitoAnnotations.openMocks(this);
        headers = new HashMap<>();
        headers.put(HTTPRequestHeaderConstants.X_HSBC_Customer_Id, "PERM123");
        ReflectionTestUtils.setField(tradeTransferService, "restClientService", restClientService);
        ReflectionTestUtils.setField(tradeTransferService, "e2ETrustTokenUtil", e2ETrustTokenUtil);
        ReflectionTestUtils.setField(tradeTransferService, "duplicateSubmitPreventionService", duplicateSubmitPreventionService);
        ReflectionTestUtils.setField(tradeTransferService, "tradeLimitService", tradeLimitService);
        ReflectionTestUtils.setField(tradeTransferService, "sreValidationService", sreValidationService);
        ReflectionTestUtils.setField(tradeTransferService, "tradeOnlineUrl", "https://trade-online.example.com");
        ReflectionTestUtils.setField(tradeTransferService, "timeout", 5000);
        ReflectionTestUtils.setField(tradeTransferService, "printMessageLog", false);
        
        lenient().when(e2ETrustTokenUtil.getE2ETrustToken()).thenReturn("dummy-token");
    }

    @Test
    void testRetrieveTransferList_success() {
        // Arrange
        String transferStatusCode = "ACTIVE";
        List<String> checksumIdentifiers = Arrays.asList("checksum1", "checksum2");
        String pagination = "{}";
        String productId = "GOLD";
        String sParameterType = "SENSITIVE";

        Map<String, String> requestHeadersRebuilt = new HashMap<>();
        requestHeadersRebuilt.put(HTTPRequestHeaderConstants.X_HSBC_CUSTOMER_ID, "CIN123");
        when(tradeTransferService.buildRequestHeaders(headers)).thenReturn(requestHeadersRebuilt);

        // Mock customer name response
        PartyNameResponse partyNameResponse = new PartyNameResponse();
        PartyNameResponseName name = new PartyNameResponseName();
        name.setLastName("Doe");
        name.setGivenName("John");
        name.setCustomerChristianName("Christian");
        partyNameResponse.setName(name);
        when(tradeTransferService.retrieveCustomerNamesWithCinNumber(anyString(), anyMap())).thenReturn(partyNameResponse);

        // Mock customer contact response
        PartyContactResponse partyContactResponse = new PartyContactResponse();
        partyContactResponse.setContact(new Object() {
            public String getMobileNumber1() { return "123456789"; }
        });
        when(tradeTransferService.retrieveCustomerPhoneNumberWithCinNumber(anyString(), anyMap())).thenReturn(partyContactResponse);

        // Mock customer accounts
        CustomerAccounts customerAccounts = new CustomerAccounts();
        InvestmentAccount account1 = new InvestmentAccount();
        account1.setChecksum("checksum1");
        account1.setInvestmentAccountId(new Object() {
            public String getCountryAccountCode() { return "HK"; }
            public String getGroupMemberAccountCode() { return "HSBC"; }
            public String getAccountNumber() { return "ACC123"; }
            public String getAccountProductTypeCode() { return "GOLD"; }
            public String getAccountTypeCode() { return "INVEST"; }
            public String getAccountCurrencyCode() { return "HKD"; }
        });
        customerAccounts.setInvestmentAccountList(Arrays.asList(account1));

        when(tradeTransferService.retrieveCustomerAccounts(anyMap())).thenReturn(customerAccounts);

        // Mock response
        RetrieveTransferListResponse mockResponse = new RetrieveTransferListResponse();
        RetrieveTransferListResponseData data = new RetrieveTransferListResponseData();
        data.setTransferLists(new ArrayList<>());
        mockResponse.setData(data);

        when(restClientService.get(anyString(), anyMap(), eq(RetrieveTransferListResponse.class), anyInt(), anyBoolean()))
                .thenReturn(mockResponse);

        // Act
        RetrieveTransferListResponse response = tradeTransferService.retrieveTransferList(headers, transferStatusCode, checksumIdentifiers, pagination, productId, sParameterType);

        // Assert
        assertThat(response).isNotNull();
        verify(restClientService).get(anyString(), anyMap(), eq(RetrieveTransferListResponse.class), anyInt(), anyBoolean());
    }

    @Test
    void testRetrieveTransferDetail_success() {
        // Arrange
        String transferReferenceNumber = "TRF123";

        Map<String, String> requestHeadersRebuilt = new HashMap<>();
        requestHeadersRebuilt.put(HTTPRequestHeaderConstants.X_HSBC_CUSTOMER_ID, "CIN123");
        when(tradeTransferService.buildRequestHeaders(headers)).thenReturn(requestHeadersRebuilt);

        // Mock customer name response
        PartyNameResponse partyNameResponse = new PartyNameResponse();
        PartyNameResponseName name = new PartyNameResponseName();
        name.setLastName("Doe");
        name.setGivenName("John");
        name.setCustomerChristianName("Christian");
        partyNameResponse.setName(name);
        when(tradeTransferService.retrieveCustomerNamesWithCinNumber(anyString(), anyMap())).thenReturn(partyNameResponse);

        // Mock customer contact response
        PartyContactResponse partyContactResponse = new PartyContactResponse();
        partyContactResponse.setContact(new Object() {
            public String getMobileNumber1() { return "123456789"; }
        });
        when(tradeTransferService.retrieveCustomerPhoneNumberWithCinNumber(anyString(), anyMap())).thenReturn(partyContactResponse);

        // Mock customer accounts
        CustomerAccounts customerAccounts = new CustomerAccounts();
        InvestmentAccount account1 = new InvestmentAccount();
        account1.setChecksum("checksum1");
        account1.setInvestmentAccountId(new Object() {
            public String getAccountNumber() { return "ACC123"; }
        });
        customerAccounts.setInvestmentAccountList(Arrays.asList(account1));

        when(tradeTransferService.retrieveCustomerAccounts(anyMap())).thenReturn(customerAccounts);

        // Mock response
        RetrieveTransferDetailResponse mockResponse = new RetrieveTransferDetailResponse();
        RetrieveTransferDetailResponseData data = new RetrieveTransferDetailResponseData();
        data.setInvestmentAccount(new Object() {
            public String getAccountNumber() { return "ACC123"; }
        });
        data.setTransferSideCode(TransferSideCode.SENDER);
        mockResponse.setData(data);

        when(restClientService.get(anyString(), anyMap(), eq(RetrieveTransferDetailResponse.class), anyInt(), anyBoolean()))
                .thenReturn(mockResponse);

        // Act
        RetrieveTransferDetailResponse response = tradeTransferService.retrieveTransferDetail(headers, transferReferenceNumber);

        // Assert
        assertThat(response).isNotNull();
        verify(restClientService).get(anyString(), anyMap(), eq(RetrieveTransferDetailResponse.class), anyInt(), anyBoolean());
    }

    @Test
    void testRetrieveTransferDetail_accountNotFound_throwsException() {
        // Arrange
        String transferReferenceNumber = "TRF123";

        Map<String, String> requestHeadersRebuilt = new HashMap<>();
        requestHeadersRebuilt.put(HTTPRequestHeaderConstants.X_HSBC_CUSTOMER_ID, "CIN123");
        when(tradeTransferService.buildRequestHeaders(headers)).thenReturn(requestHeadersRebuilt);

        // Mock customer name response
        PartyNameResponse partyNameResponse = new PartyNameResponse();
        PartyNameResponseName name = new PartyNameResponseName();
        name.setLastName("Doe");
        name.setGivenName("John");
        name.setCustomerChristianName("Christian");
        partyNameResponse.setName(name);
        when(tradeTransferService.retrieveCustomerNamesWithCinNumber(anyString(), anyMap())).thenReturn(partyNameResponse);

        // Mock customer contact response
        PartyContactResponse partyContactResponse = new PartyContactResponse();
        partyContactResponse.setContact(new Object() {
            public String getMobileNumber1() { return "123456789"; }
        });
        when(tradeTransferService.retrieveCustomerPhoneNumberWithCinNumber(anyString(), anyMap())).thenReturn(partyContactResponse);

        // Mock customer accounts with no matching account
        CustomerAccounts customerAccounts = new CustomerAccounts();
        InvestmentAccount account1 = new InvestmentAccount();
        account1.setChecksum("checksum1");
        account1.setInvestmentAccountId(new Object() {
            public String getAccountNumber() { return "DIFFERENT_ACC"; }
        });
        customerAccounts.setInvestmentAccountList(Arrays.asList(account1));

        when(tradeTransferService.retrieveCustomerAccounts(anyMap())).thenReturn(customerAccounts);

        // Mock response
        RetrieveTransferDetailResponse mockResponse = new RetrieveTransferDetailResponse();
        RetrieveTransferDetailResponseData data = new RetrieveTransferDetailResponseData();
        data.setInvestmentAccount(new Object() {
            public String getAccountNumber() { return "ACC123"; }
        });
        data.setTransferSideCode(TransferSideCode.SENDER);
        mockResponse.setData(data);

        when(restClientService.get(anyString(), anyMap(), eq(RetrieveTransferDetailResponse.class), anyInt(), anyBoolean()))
                .thenReturn(mockResponse);

        // Act & Assert
        BadRequestException exception = assertThrows(BadRequestException.class, () -> 
            tradeTransferService.retrieveTransferDetail(headers, transferReferenceNumber));
        assertThat(exception.getMessage()).contains("ACCOUNT_LIST_EMPTY_ERROR");
    }

    @Test
    void testCreateTransfers_success() {
        // Arrange
        CreateTransferRequest request = new CreateTransferRequest();
        CreateTransferRequest.Data requestData = new CreateTransferRequest.Data();
        requestData.setSenderInvestmentAccountChecksumIdentifier("checksum1");
        requestData.setActionRequestCode(ActionRequestCode.D);
        requestData.setRequestPriceValue(BigDecimal.valueOf(100));
        
        List<ReceiverInfo> receivers = new ArrayList<>();
        ReceiverInfo receiver = new ReceiverInfo();
        receiver.setTransferQuantity(BigDecimal.valueOf(2));
        receivers.add(receiver);
        requestData.setReceiverLists(receivers);
        
        request.setData(requestData);

        Map<String, String> requestHeaders = new HashMap<>();
        requestHeaders.put(HTTPRequestHeaderConstants.X_HSBC_CUSTOMER_ID, "CIN123");
        when(tradeTransferService.buildRequestHeaders(headers)).thenReturn(requestHeaders);

        // Mock limit check
        RetrieveTransferLimitResponse limitResponse = new RetrieveTransferLimitResponse();
        RetrieveTransferLimitResponseData limitData = new RetrieveTransferLimitResponseData();
        limitData.setAvailableTodayAmount(BigDecimal.valueOf(1000));
        limitData.setMaxDailyLimitedAmount(BigDecimal.valueOf(2000));
        limitData.setAvailableMonthToDateAmount(BigDecimal.valueOf(1000));
        limitData.setMaxMonthlyLimitedAmount(BigDecimal.valueOf(2000));
        limitData.setAvailableYearToDateAmount(BigDecimal.valueOf(1000));
        limitData.setMaxYearlyLimitedAmount(BigDecimal.valueOf(2000));
        limitResponse.setData(limitData);
        when(tradeLimitService.retrieveLimitations(anyMap())).thenReturn(limitResponse);

        // Mock account ID
        when(tradeTransferService.retrieveAccountIdWithCheckSum(anyMap())).thenReturn(new Object() {
            public String getAccountNumber() { return "ACC123"; }
        });

        // Mock SRE validation
        when(sreValidationService.callSreForTransferValidation(anyString(), anyString(), anyString(), anyMap())).thenReturn(new Object() {
            public boolean isSuccessful() { return true; }
        });

        // Mock customer name
        PartyNameResponse partyNameResponse = new PartyNameResponse();
        PartyNameResponseName name = new PartyNameResponseName();
        name.setLastName("Doe");
        name.setGivenName("John");
        name.setCustomerChristianName("Christian");
        partyNameResponse.setName(name);
        when(tradeTransferService.retrieveCustomerNamesWithCinNumber(anyString(), anyMap())).thenReturn(partyNameResponse);

        // Mock gold price
        GoldPriceResponse goldPriceResponse = new GoldPriceResponse();
        GoldPriceResponseData goldPriceData = new GoldPriceResponseData();
        goldPriceData.setGoldPriceAmount(BigDecimal.valueOf(150));
        goldPriceData.setPublishTime("2023-10-27T10:00:00");
        goldPriceResponse.setData(goldPriceData);
        when(tradeTransferService.retrieveGoldPrice(anyMap())).thenReturn(goldPriceResponse);

        // Mock response
        CreateTransferResponse mockResponse = new CreateTransferResponse();
        CreateTransferResponse.Data responseData = new CreateTransferResponse.Data();
        responseData.setTransferOrderLists(new ArrayList<>());
        mockResponse.setData(responseData);

        when(restClientService.post(anyString(), anyMap(), any(CreateTransferRequest.class), eq(CreateTransferResponse.class), anyInt(), anyBoolean()))
                .thenReturn(mockResponse);

        when(duplicateSubmitPreventionService.generateUniqueKey()).thenReturn("unique-key");

        // Act
        CreateTransferResponse response = tradeTransferService.createTransfers(headers, request);

        // Assert
        assertThat(response).isNotNull();
        verify(restClientService).post(anyString(), anyMap(), any(CreateTransferRequest.class), eq(CreateTransferResponse.class), anyInt(), anyBoolean());
    }

    @Test
    void testCreateTransfers_dailyLimitExceeded_throwsException() {
        // Arrange
        CreateTransferRequest request = new CreateTransferRequest();
        CreateTransferRequest.Data requestData = new CreateTransferRequest.Data();
        requestData.setSenderInvestmentAccountChecksumIdentifier("checksum1");
        requestData.setActionRequestCode(ActionRequestCode.D);
        requestData.setRequestPriceValue(BigDecimal.valueOf(100));
        
        List<ReceiverInfo> receivers = new ArrayList<>();
        ReceiverInfo receiver = new ReceiverInfo();
        receiver.setTransferQuantity(BigDecimal.valueOf(2));
        receivers.add(receiver);
        requestData.setReceiverLists(receivers);
        
        request.setData(requestData);

        Map<String, String> requestHeaders = new HashMap<>();
        requestHeaders.put(HTTPRequestHeaderConstants.X_HSBC_CUSTOMER_ID, "CIN123");
        when(tradeTransferService.buildRequestHeaders(headers)).thenReturn(requestHeaders);

        // Mock limit check - available amount is less than total amount
        RetrieveTransferLimitResponse limitResponse = new RetrieveTransferLimitResponse();
        RetrieveTransferLimitResponseData limitData = new RetrieveTransferLimitResponseData();
        limitData.setAvailableTodayAmount(BigDecimal.valueOf(100)); // Less than total amount (200)
        limitData.setMaxDailyLimitedAmount(BigDecimal.valueOf(2000));
        limitData.setAvailableMonthToDateAmount(BigDecimal.valueOf(1000));
        limitData.setMaxMonthlyLimitedAmount(BigDecimal.valueOf(2000));
        limitData.setAvailableYearToDateAmount(BigDecimal.valueOf(1000));
        limitData.setMaxYearlyLimitedAmount(BigDecimal.valueOf(2000));
        limitResponse.setData(limitData);
        when(tradeLimitService.retrieveLimitations(anyMap())).thenReturn(limitResponse);

        // Act & Assert
        TransferLimitExceededException exception = assertThrows(TransferLimitExceededException.class, () -> 
            tradeTransferService.createTransfers(headers, request));
        assertThat(exception.getMessage()).contains("Daily limit exceeded");
    }

    @Test
    void testModifyTransfers_success() {
        // Arrange
        UpdateTransferRequest request = new UpdateTransferRequest();
        UpdateTransferRequest.Data requestData = new UpdateTransferRequest.Data();
        requestData.setTransferActionCode(TransferActionCode.A); // Accept
        requestData.setReceiverCustomerInternalNumber("CIN456");
        requestData.setReceiverInvestmentAccountChecksumIdentifier("checksum2");
        request.setData(requestData);

        Map<String, String> requestHeaders = new HashMap<>();
        requestHeaders.put(HTTPRequestHeaderConstants.X_HSBC_CUSTOMER_ID, "CIN123");
        when(tradeTransferService.buildRequestHeaders(headers)).thenReturn(requestHeaders);

        // Mock account ID
        when(tradeTransferService.retrieveAccountIdWithCheckSum(anyMap())).thenReturn(new Object() {
            public String getAccountNumber() { return "ACC456"; }
        });

        // Mock SRE validation
        when(sreValidationService.callSreForTransferValidation(anyString(), anyString(), anyString(), anyMap())).thenReturn(new Object() {
            public boolean isSuccessful() { return true; }
        });

        // Mock gold price
        GoldPriceResponse goldPriceResponse = new GoldPriceResponse();
        GoldPriceResponseData goldPriceData = new GoldPriceResponseData();
        goldPriceData.setGoldPriceAmount(BigDecimal.valueOf(150));
        goldPriceData.setPublishTime("2023-10-27T10:00:00");
        goldPriceResponse.setData(goldPriceData);
        when(tradeTransferService.retrieveGoldPrice(anyMap())).thenReturn(goldPriceResponse);

        // Mock response
        UpdateTransferResponse mockResponse = new UpdateTransferResponse();

        when(restClientService.put(anyString(), anyMap(), any(UpdateTransferRequest.class), eq(UpdateTransferResponse.class), anyInt(), anyBoolean()))
                .thenReturn(mockResponse);

        // Act
        UpdateTransferResponse response = tradeTransferService.modifyTransfers(headers, request);

        // Assert
        assertThat(response).isNotNull();
        verify(restClientService).put(anyString(), anyMap(), any(UpdateTransferRequest.class), eq(UpdateTransferResponse.class), anyInt(), anyBoolean());
    }

    @Test
    void testModifyTransfers_rejectAction() {
        // Arrange
        UpdateTransferRequest request = new UpdateTransferRequest();
        UpdateTransferRequest.Data requestData = new UpdateTransferRequest.Data();
        requestData.setTransferActionCode(TransferActionCode.R); // Reject
        requestData.setReceiverCustomerInternalNumber("CIN456");
        request.setData(requestData);

        Map<String, String> requestHeaders = new HashMap<>();
        requestHeaders.put(HTTPRequestHeaderConstants.X_HSBC_CUSTOMER_ID, "CIN123");
        when(tradeTransferService.buildRequestHeaders(headers)).thenReturn(requestHeaders);

        // Mock response
        UpdateTransferResponse mockResponse = new UpdateTransferResponse();

        when(restClientService.put(anyString(), anyMap(), any(UpdateTransferRequest.class), eq(UpdateTransferResponse.class), anyInt(), anyBoolean()))
                .thenReturn(mockResponse);

        // Act
        UpdateTransferResponse response = tradeTransferService.modifyTransfers(headers, request);

        // Assert
        assertThat(response).isNotNull();
        verify(restClientService).put(anyString(), anyMap(), any(UpdateTransferRequest.class), eq(UpdateTransferResponse.class), anyInt(), anyBoolean());
    }

    @Test
    void testExtractAccountIdMap_success() {
        // Arrange
        CustomerAccounts customerAccounts = new CustomerAccounts();
        InvestmentAccount account1 = new InvestmentAccount();
        account1.setChecksum("checksum1");
        account1.setInvestmentAccountId(new Object() {
            public String getCountryAccountCode() { return "HK"; }
            public String getGroupMemberAccountCode() { return "HSBC"; }
            public String getAccountNumber() { return "ACC123"; }
            public String getAccountProductTypeCode() { return "GOLD"; }
            public String getAccountTypeCode() { return "INVEST"; }
            public String getAccountCurrencyCode() { return "HKD"; }
        });
        customerAccounts.setInvestmentAccountList(Arrays.asList(account1));

        // Act
        Map<String, String> result = tradeTransferService.extractAccountIdMap(customerAccounts);

        // Assert
        assertThat(result).isNotNull();
        assertThat(result).hasSize(1);
        assertThat(result.get("checksum1")).isEqualTo("countryAccountCode=HK;groupMemberAccountCode=HSBC;accountNumber=ACC123;accountProductTypeCode=GOLD;accountTypeCode=INVEST;accountCurrencyCode=HKD");
    }

    @Test
    void testExtractAccountIdMap_nullAccounts() {
        // Act
        Map<String, String> result = tradeTransferService.extractAccountIdMap(null);

        // Assert
        assertThat(result).isNotNull();
        assertThat(result).isEmpty();
    }

    @Test
    void testValidateTransferLimits_dailyLimitExceeded() {
        // Arrange
        RetrieveTransferLimitResponse limitResponse = new RetrieveTransferLimitResponse();
        RetrieveTransferLimitResponseData limitData = new RetrieveTransferLimitResponseData();
        limitData.setAvailableTodayAmount(BigDecimal.valueOf(100));
        limitData.setMaxDailyLimitedAmount(BigDecimal.valueOf(2000));
        limitData.setAvailableMonthToDateAmount(BigDecimal.valueOf(1000));
        limitData.setMaxMonthlyLimitedAmount(BigDecimal.valueOf(2000));
        limitData.setAvailableYearToDateAmount(BigDecimal.valueOf(1000));
        limitData.setMaxYearlyLimitedAmount(BigDecimal.valueOf(2000));
        limitResponse.setData(limitData);

        // Act & Assert
        TransferLimitExceededException exception = assertThrows(TransferLimitExceededException.class, () -> 
            tradeTransferService.validateTransferLimits(BigDecimal.valueOf(150), limitResponse));
        assertThat(exception.getMessage()).contains("Daily limit exceeded");
    }

    @Test
    void testValidateTransferLimits_monthlyLimitExceeded() {
        // Arrange
        RetrieveTransferLimitResponse limitResponse = new RetrieveTransferLimitResponse();
        RetrieveTransferLimitResponseData limitData = new RetrieveTransferLimitResponseData();
        limitData.setAvailableTodayAmount(BigDecimal.valueOf(1000));
        limitData.setMaxDailyLimitedAmount(BigDecimal.valueOf(2000));
        limitData.setAvailableMonthToDateAmount(BigDecimal.valueOf(100));
        limitData.setMaxMonthlyLimitedAmount(BigDecimal.valueOf(2000));
        limitData.setAvailableYearToDateAmount(BigDecimal.valueOf(1000));
        limitData.setMaxYearlyLimitedAmount(BigDecimal.valueOf(2000));
        limitResponse.setData(limitData);

        // Act & Assert
        TransferLimitExceededException exception = assertThrows(TransferLimitExceededException.class, () -> 
            tradeTransferService.validateTransferLimits(BigDecimal.valueOf(150), limitResponse));
        assertThat(exception.getMessage()).contains("Monthly limit exceeded");
    }

    @Test
    void testValidateTransferLimits_yearlyLimitExceeded() {
        // Arrange
        RetrieveTransferLimitResponse limitResponse = new RetrieveTransferLimitResponse();
        RetrieveTransferLimitResponseData limitData = new RetrieveTransferLimitResponseData();
        limitData.setAvailableTodayAmount(BigDecimal.valueOf(1000));
        limitData.setMaxDailyLimitedAmount(BigDecimal.valueOf(2000));
        limitData.setAvailableMonthToDateAmount(BigDecimal.valueOf(1000));
        limitData.setMaxMonthlyLimitedAmount(BigDecimal.valueOf(2000));
        limitData.setAvailableYearToDateAmount(BigDecimal.valueOf(100));
        limitData.setMaxYearlyLimitedAmount(BigDecimal.valueOf(2000));
        limitResponse.setData(limitData);

        // Act & Assert
        TransferLimitExceededException exception = assertThrows(TransferLimitExceededException.class, () -> 
            tradeTransferService.validateTransferLimits(BigDecimal.valueOf(150), limitResponse));
        assertThat(exception.getMessage()).contains("Yearly limit exceeded");
    }

    @Test
    void testFindAccountChecksumForAccountNumber_success() {
        // Arrange
        CustomerAccounts customerAccounts = new CustomerAccounts();
        InvestmentAccount account1 = new InvestmentAccount();
        account1.setChecksum("checksum1");
        account1.setInvestmentAccountId(new Object() {
            public String getAccountNumber() { return "ACC123"; }
        });
        InvestmentAccount account2 = new InvestmentAccount();
        account2.setChecksum("checksum2");
        account2.setInvestmentAccountId(new Object() {
            public String getAccountNumber() { return "ACC456"; }
        });
        customerAccounts.setInvestmentAccountList(Arrays.asList(account1, account2));

        // Act
        String result = tradeTransferService.findAccountChecksumForAccountNumber(customerAccounts, "ACC123");

        // Assert
        assertThat(result).isEqualTo("checksum1");
    }

    @Test
    void testFindAccountChecksumForAccountNumber_notFound() {
        // Arrange
        CustomerAccounts customerAccounts = new CustomerAccounts();
        InvestmentAccount account1 = new InvestmentAccount();
        account1.setChecksum("checksum1");
        account1.setInvestmentAccountId(new Object() {
            public String getAccountNumber() { return "ACC123"; }
        });
        customerAccounts.setInvestmentAccountList(Arrays.asList(account1));

        // Act
        String result = tradeTransferService.findAccountChecksumForAccountNumber(customerAccounts, "NONEXISTENT");

        // Assert
        assertThat(result).isNull();
    }
}
