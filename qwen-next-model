package com.hsbc.trade.transfer.service.impl;

import com.hsbc.trade.HTTPRequestHeaderConstants;
import com.hsbc.trade.common.ResponseDetails;
import com.hsbc.trade.service.RestClientService;
import com.hsbc.trade.service.impl.RetrieveCustomerProfilesServiceImpl;
import com.hsbc.trade.transfer.common.*;
import com.hsbc.trade.transfer.createtransfer.*;
import com.hsbc.trade.transfer.domain.*;
import com.hsbc.trade.transfer.domain.account.*;
import com.hsbc.trade.transfer.domain.eligibility.RuleResponse;
import com.hsbc.trade.transfer.domain.mds.GoldPriceResponse;
import com.hsbc.trade.transfer.domain.mds.GoldPriceResponseData;
import com.hsbc.trade.transfer.exception.TransferLimitExceededException;
import com.hsbc.trade.transfer.retrievetransferdetail.RetrieveTransferDetailResponse;
import com.hsbc.trade.transfer.retrievetransferdetail.RetrieveTransferDetailResponseData;
import com.hsbc.trade.transfer.retrievetransferlimit.RetrieveTransferLimitResponse;
import com.hsbc.trade.transfer.retrievetransferlimit.RetrieveTransferLimitResponseData;
import com.hsbc.trade.transfer.retrievetransferlist.RetrieveTransferListResponse;
import com.hsbc.trade.transfer.retrievetransferlist.RetrieveTransferListResponseData;
import com.hsbc.trade.transfer.service.SreValidationServiceImpl;
import com.hsbc.trade.transfer.updatetransfer.UpdateTransferRequest;
import com.hsbc.trade.transfer.updatetransfer.UpdateTransferRequestData;
import com.hsbc.trade.transfer.updatetransfer.UpdateTransferResponse;
import com.hsbc.trade.utils.E2ETrustTokenUtil;
import jakarta.ws.rs.BadRequestException;
import jakarta.ws.rs.InternalServerErrorException;
import org.junit.jupiter.api.*;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.*;
import org.mockito.junit.jupiter.MockitoExtension;
import org.springframework.test.util.ReflectionTestUtils;

import java.math.BigDecimal;
import java.util.*;
import java.util.stream.Collectors;

import static org.junit.jupiter.api.Assertions.*;
import static org.mockito.ArgumentMatchers.*;
import static org.mockito.Mockito.*;

@ExtendWith(MockitoExtension.class)
class TradeTransferServiceImplTest {

    @InjectMocks
    private TradeTransferServiceImpl tradeTransferService;

    @Mock
    private RestClientService restClientService;

    @Mock
    private RetrieveCustomerProfilesServiceImpl retrieveCustomerProfilesService;

    @Mock
    private SreValidationServiceImpl sreValidationService;

    @Mock
    private E2ETrustTokenUtil e2ETrustTokenUtil;

    @Mock
    private DuplicateSubmitPreventionService duplicateSubmitPreventionService; // 用于 handleDOperationResponse

    @BeforeEach
    void setUp() {
        // 设置基础URL
        ReflectionTestUtils.setField(tradeTransferService, "tradeOnlineUrl", "https://dummy.trade");
        ReflectionTestUtils.setField(tradeTransferService, "customerAccountUrl", "https://dummy.accounts");
        ReflectionTestUtils.setField(tradeTransferService, "retrieveCustomerProfilesService", retrieveCustomerProfilesService);
        ReflectionTestUtils.setField(tradeTransferService, "sreValidationService", sreValidationService);
        ReflectionTestUtils.setField(tradeTransferService, "duplicateSubmitPreventionService", duplicateSubmitPreventionService); // 注入Mock

        // Mock CIN获取，这是许多方法的前置条件
        lenient().when(retrieveCustomerProfilesService.getCIN(any())).thenReturn("dummy-cin");

        // Mock SAML Token，用于构建请求头
        dummyToken = "<saml:Assertion xmlns:saml='http://www.hsbc.com/saas/assertion' xmlns:ds='http://www.w3.org/2000/09/xmldsig#' xmlns:xsi='http://www.w3.org/2001/XMLSchema-instance' ID='id_9a9e4d35-7d80-4805-849f-ddb90a8b2c1f' IssueInstant='2025-08-07T01:25:13.837Z' Version='3.0'><saml:Issuer>https://www.hsbc.com/rbwm/dtp</saml:Issuer><ds:Signature><ds:SignedInfo><ds:CanonicalizationMethod Algorithm='http://www.w3.org/2001/10/xml-exc-c14n#'/><ds:SignatureMethod Algorithm='http://www.w3.org/2001/04/xmldsig-more#rsa-sha256'/><ds:Reference URI='#id_9a9e4d35-7d80-4805-849f-ddb90a8b2c1f'><ds:Transforms><ds:Transform Algorithm='http://www.w3.org/2000/09/xmldsig#enveloped-signature'/><ds:Transform Algorithm='http://www.w3.org/2001/10/xml-exc-c14n#'><ds:InclusiveNamespaces xmlns:ds='http://www.w3.org/2001/10/xml-exc-c14n#' PrefixList='#default saml ds xs xsi'/></ds:Transform></ds:Transforms><ds:DigestMethod Algorithm='http://www.w3.org/2001/04/xmlenc#sha256'/><ds:DigestValue>GLd2xpRi6DRAl81eH6NBRNzVWBlEL1zn5mWNpp16xCk=</ds:DigestValue></ds:Reference></ds:SignedInfo><ds:SignatureValue>IJQo3CpyjsDRTfXdnQGQnugNniIy56neA0eaLr87DITEauIPFNZHGCk6sb/Wp9PSIxoJNGpF4T5vVPWqUmv1fYasVtrukqodTgK2JD3NHhviDmTVGKzhZ2hnfjSewDRYeqHVURHMWY1EzltUhpZgO9u12i9+PPK4OJLFDR5Q4tZico3GfweUS7+Ds9wYssqgECZg3XayVg5w9ruSdxPIrcjU7aOe2sZFkge+I6cD2OWHC0K+u+PG+DD0UNmK9OnIY///lwgUdhbdSv0zdkUhOcHRKstuFIKhb4E8eZDogB5Sjeqya3EwJ8sIda99n+jug9IrDAjQIBTTnxtMfwq+gQ==</ds:SignatureValue></ds:Signature><saml:Subject><saml:NameID>HK00100718688801</saml:NameID></saml:Subject><saml:Conditions NotBefore='2025-08-07T01:25:12.837Z' NotOnOrAfter='2025-08-07T01:26:13.837Z'/><saml:AttributeStatement><saml:Attribute Name='GUID'><saml:AttributeValue>98b45150-5c73-11ea-8a50-0350565a170c</saml:AttributeValue></saml:Attribute><saml:Attribute Name='CAM'><saml:AttributeValue>30</saml:AttributeValue></saml:Attribute><saml:Attribute Name='KeyAlias'><saml:AttributeValue>E2E_TRUST_SAAS_AP01_BRTB1_ALIAS</saml:AttributeValue></saml:Attribute></saml:AttributeStatement></saml:Assertion>";
    }

    private String dummyToken;

    // ==================== retrieveTransferList ====================

    @Test
    void retrieveTransferList_Success() {
        // Arrange
        Map<String, String> requestHeader = buildValidRequestHeader();
        String transferStatusCode = "ACCEPTED";
        List<String> checksumIdentifiers = Arrays.asList("chk1", "chk2");
        String pagination = "page=1";
        String productId = "PROD1";
        String sParameterType = "PLAIN_TEXT";

        // Mock response
        RetrieveTransferListResponse mockResponse = new RetrieveTransferListResponse();
        RetrieveTransferListResponseData responseData = new RetrieveTransferListResponseData();
        responseData.setTransferLists(new ArrayList<>());
        mockResponse.setData(responseData);
        ResponseDetails responseDetails = new ResponseDetails();
        responseDetails.setResponseCodeNumber(0);
        mockResponse.setResponseDetails(responseDetails);

        // Mock the underlying calls that are part of the flow
        CustomerAccounts customerAccounts = new CustomerAccounts();
        InvestmentAccount account1 = new InvestmentAccount();
        account1.setChecksum("chk1");
        InvestmentAccountId accountId1 = new InvestmentAccountId();
        accountId1.setAccountNumber("ACC1");
        account1.setInvestmentAccountId(accountId1);
        InvestmentAccount account2 = new InvestmentAccount();
        account2.setChecksum("chk2");
        InvestmentAccountId accountId2 = new InvestmentAccountId();
        accountId2.setAccountNumber("ACC2");
        account2.setInvestmentAccountId(accountId2);
        customerAccounts.setInvestmentAccountList(Arrays.asList(account1, account2));

        // Mock customer accounts retrieval
        when(restClientService.get(anyString(), any(), eq(CustomerAccounts.class), anyInt(), anyBoolean()))
                .thenReturn(customerAccounts);

        // Mock the main REST call
        when(restClientService.get(anyString(), anyMap(), eq(RetrieveTransferListResponse.class), anyInt(), anyBoolean()))
                .thenReturn(mockResponse);

        // Mock PartyNameResponse and PartyContactResponse
        PartyNameResponse partyNameResponse = new PartyNameResponse();
        PartyNameResponse.Name name = new PartyNameResponse.Name();
        name.setLastName("Smith");
        name.setGivenName("John");
        name.setCustomerChristianName("J");
        partyNameResponse.setName(name);
        when(retrieveCustomerProfilesService.retrieveCustomerNamesWithCinNumber(anyString(), anyMap()))
                .thenReturn(partyNameResponse);

        PartyContactResponse partyContactResponse = new PartyContactResponse();
        PartyContactResponse.Contact contact = new PartyContactResponse.Contact();
        contact.setMobileNumber1("12345678");
        partyContactResponse.setContact(contact);
        when(retrieveCustomerProfilesService.retrieveCustomerPhoneNumberWithCinNumber(anyString(), anyMap()))
                .thenReturn(partyContactResponse);

        // Act
        RetrieveTransferListResponse result = tradeTransferService.retrieveTransferList(requestHeader, transferStatusCode, checksumIdentifiers, pagination, productId, sParameterType);

        // Assert
        assertNotNull(result);
        assertEquals(0, result.getResponseDetails().getResponseCodeNumber());
        verify(restClientService).get(anyString(), anyMap(), eq(RetrieveTransferListResponse.class), anyInt(), anyBoolean());
        verify(retrieveCustomerProfilesService).retrieveCustomerNamesWithCinNumber(eq("dummy-cin"), anyMap());
        verify(retrieveCustomerProfilesService).retrieveCustomerPhoneNumberWithCinNumber(eq("dummy-cin"), anyMap());
    }

    @Test
    void retrieveTransferList_WhenCustomerAccountsEmpty_ThrowsBadRequestException() {
        // Arrange
        Map<String, String> requestHeader = buildValidRequestHeader();
        String transferStatusCode = "ACCEPTED";

        // Mock empty customer accounts
        CustomerAccounts customerAccounts = new CustomerAccounts();
        customerAccounts.setInvestmentAccountList(new ArrayList<>());

        when(restClientService.get(anyString(), any(), eq(CustomerAccounts.class), anyInt(), anyBoolean()))
                .thenReturn(customerAccounts);

        // Mock other calls to avoid NPE
        when(retrieveCustomerProfilesService.retrieveCustomerNamesWithCinNumber(anyString(), anyMap()))
                .thenReturn(new PartyNameResponse());
        when(retrieveCustomerProfilesService.retrieveCustomerPhoneNumberWithCinNumber(anyString(), anyMap()))
                .thenReturn(new PartyContactResponse());

        // Act & Assert
        assertThrows(BadRequestException.class, () -> {
            tradeTransferService.retrieveTransferList(requestHeader, transferStatusCode, Collections.emptyList(), "1", "PROD1", "PLAIN_TEXT");
        });
    }

    // ==================== retrieveTransferDetail ====================

    @Test
    void retrieveTransferDetail_Success() {
        // Arrange
        Map<String, String> requestHeader = buildValidRequestHeader();
        String transferReferenceNumber = "TRF12345";

        // Mock response
        RetrieveTransferDetailResponse mockResponse = new RetrieveTransferDetailResponse();
        RetrieveTransferDetailResponseData responseData = new RetrieveTransferDetailResponseData();
        responseData.setTransferSideCode(TransferSideCode.SENDER);
        responseData.setIsReceiverBankCustomer("Y");
        responseData.setSenderCustomerFirstName("John");
        responseData.setSenderCustomerMiddleName("A");
        responseData.setSenderCustomerLastName("Doe");
        InvestmentAccount investmentAccount = new InvestmentAccount();
        InvestmentAccountId accountId = new InvestmentAccountId();
        accountId.setAccountNumber("123456");
        investmentAccount.setInvestmentAccountId(accountId);
        responseData.setInvestmentAccount(investmentAccount);
        mockResponse.setData(responseData);
        ResponseDetails responseDetails = new ResponseDetails();
        responseDetails.setResponseCodeNumber(0);
        mockResponse.setResponseDetails(responseDetails);

        // Mock customer accounts with matching account number
        CustomerAccounts customerAccounts = new CustomerAccounts();
        InvestmentAccount account = new InvestmentAccount();
        account.setChecksum("validChecksum");
        account.setInvestmentAccountId(accountId); // Same account number as in response
        customerAccounts.setInvestmentAccountList(Collections.singletonList(account));

        when(restClientService.get(anyString(), any(), eq(CustomerAccounts.class), anyInt(), anyBoolean()))
                .thenReturn(customerAccounts);

        // Mock the main REST call
        when(restClientService.get(anyString(), anyMap(), eq(RetrieveTransferDetailResponse.class), anyInt(), anyBoolean()))
                .thenReturn(mockResponse);

        // Mock PartyNameResponse and PartyContactResponse
        PartyNameResponse partyNameResponse = new PartyNameResponse();
        PartyNameResponse.Name name = new PartyNameResponse.Name();
        name.setLastName("Smith");
        name.setGivenName("John");
        name.setCustomerChristianName("J");
        partyNameResponse.setName(name);
        when(retrieveCustomerProfilesService.retrieveCustomerNamesWithCinNumber(anyString(), anyMap()))
                .thenReturn(partyNameResponse);

        PartyContactResponse partyContactResponse = new PartyContactResponse();
        PartyContactResponse.Contact contact = new PartyContactResponse.Contact();
        contact.setMobileNumber1("12345678");
        partyContactResponse.setContact(contact);
        when(retrieveCustomerProfilesService.retrieveCustomerPhoneNumberWithCinNumber(anyString(), anyMap()))
                .thenReturn(partyContactResponse);

        // Act
        RetrieveTransferDetailResponse result = tradeTransferService.retrieveTransferDetail(requestHeader, transferReferenceNumber);

        // Assert
        assertNotNull(result);
        assertEquals("validChecksum", result.getData().getAccountChecksumIdentifier());
        assertEquals("J****n", result.getData().getSenderCustomerFirstName()); // Masked
        assertEquals("A***", result.getData().getSenderCustomerMiddleName()); // Masked
        verify(restClientService).get(anyString(), anyMap(), eq(RetrieveTransferDetailResponse.class), anyInt(), anyBoolean());
    }

    @Test
    void retrieveTransferDetail_WhenInvestmentAccountIsNull_ThrowsBadRequestException() {
        // Arrange
        Map<String, String> requestHeader = buildValidRequestHeader();
        String transferReferenceNumber = "TRF12345";

        // Mock response with null investmentAccount
        RetrieveTransferDetailResponse mockResponse = new RetrieveTransferDetailResponse();
        RetrieveTransferDetailResponseData responseData = new RetrieveTransferDetailResponseData();
        responseData.setInvestmentAccount(null); // This will trigger the error
        mockResponse.setData(responseData);
        ResponseDetails responseDetails = new ResponseDetails();
        responseDetails.setResponseCodeNumber(0);
        mockResponse.setResponseDetails(responseDetails);

        // Mock customer accounts (empty, so no match will be found)
        CustomerAccounts customerAccounts = new CustomerAccounts();
        customerAccounts.setInvestmentAccountList(new ArrayList<>());

        when(restClientService.get(anyString(), any(), eq(CustomerAccounts.class), anyInt(), anyBoolean()))
                .thenReturn(customerAccounts);

        // Mock the main REST call
        when(restClientService.get(anyString(), anyMap(), eq(RetrieveTransferDetailResponse.class), anyInt(), anyBoolean()))
                .thenReturn(mockResponse);

        // Mock PartyNameResponse and PartyContactResponse
        PartyNameResponse partyNameResponse = new PartyNameResponse();
        partyNameResponse.setName(new PartyNameResponse.Name());
        when(retrieveCustomerProfilesService.retrieveCustomerNamesWithCinNumber(anyString(), anyMap()))
                .thenReturn(partyNameResponse);

        PartyContactResponse partyContactResponse = new PartyContactResponse();
        partyContactResponse.setContact(new PartyContactResponse.Contact());
        when(retrieveCustomerProfilesService.retrieveCustomerPhoneNumberWithCinNumber(anyString(), anyMap()))
                .thenReturn(partyContactResponse);

        // Act & Assert
        assertThrows(BadRequestException.class, () -> {
            tradeTransferService.retrieveTransferDetail(requestHeader, transferReferenceNumber);
        });
    }

    @Test
    void retrieveTransferDetail_WhenRestCallFails_ThrowsInternalServerErrorException() {
        // Arrange
        Map<String, String> requestHeader = buildValidRequestHeader();
        String transferReferenceNumber = "TRF12345";

        // Mock a failure in the REST call
        when(restClientService.get(anyString(), anyMap(), eq(RetrieveTransferDetailResponse.class), anyInt(), anyBoolean()))
                .thenThrow(new RuntimeException("Network error"));

        // Act & Assert
        assertThrows(InternalServerErrorException.class, () -> {
            tradeTransferService.retrieveTransferDetail(requestHeader, transferReferenceNumber);
        });
    }

    // ==================== createTransfers ====================

    @Test
    void createTransfers_Success_DOperation() {
        // Arrange
        Map<String, String> requestHeader = buildValidRequestHeader();
        CreateTransferRequest request = new CreateTransferRequest();
        CreateTransferRequestData data = new CreateTransferRequestData();
        data.setActionRequestCode(ActionRequestCode.D); // D operation
        data.setSenderInvestmentAccountChecksumIdentifier("chk1");

        ReceiverInfo receiver = new ReceiverInfo();
        receiver.setTransferQuantity(new BigDecimal("100.00"));
        receiver.setReceiverCustomerNumber("CUST001");
        data.setReceiverLists(Collections.singletonList(receiver));

        request.setData(data);

        // Mock customer accounts
        CustomerAccounts customerAccounts = new CustomerAccounts();
        InvestmentAccount account = new InvestmentAccount();
        account.setChecksum("chk1");
        InvestmentAccountId accountId = new InvestmentAccountId();
        accountId.setAccountNumber("ACC123");
        accountId.setCountryAccountCode("HK");
        accountId.setGroupMemberAccountCode("HBAP");
        accountId.setAccountProductTypeCode("SAV");
        accountId.setAccountTypeCode("01");
        accountId.setAccountCurrencyCode("HKD");
        account.setInvestmentAccountId(accountId);
        customerAccounts.setInvestmentAccountList(Collections.singletonList(account));

        when(restClientService.get(anyString(), any(), eq(CustomerAccounts.class), anyInt(), anyBoolean()))
                .thenReturn(customerAccounts);

        // Mock limit check
        RetrieveTransferLimitResponse currentLimit = new RetrieveTransferLimitResponse();
        RetrieveTransferLimitResponseData limitData = new RetrieveTransferLimitResponseData();
        limitData.setAvailableTodayAmount(new BigDecimal("1000"));
        limitData.setMaxDailyLimitedAmount(new BigDecimal("1000"));
        limitData.setAvailableMonthToDateAmount(new BigDecimal("2000"));
        limitData.setMaxMonthlyLimitedAmount(new BigDecimal("2000"));
        limitData.setAvailableYearToDateAmount(new BigDecimal("5000"));
        limitData.setMaxYearlyLimitedAmount(new BigDecimal("5000"));
        currentLimit.setData(limitData);

        // Mock SRE validation for receiver
        RuleResponse sreResponse = new RuleResponse();
        ResponseDetails sreDetails = new ResponseDetails();
        sreDetails.setResponseCodeNumber(0);
        sreResponse.setResponseDetails(sreDetails);
        when(sreValidationService.callSreForTransferValidation(anyString(), anyString(), anyString(), anyMap()))
                .thenReturn(sreResponse);

        // Mock Gold Price for D operation
        GoldPriceResponse goldPriceResponse = new GoldPriceResponse();
        GoldPriceResponseData mdsData = new GoldPriceResponseData();
        mdsData.setGoldPriceAmount(new BigDecimal("50.00"));
        mdsData.setPublishTime("2025-11-20T10:00:00Z");
        goldPriceResponse.setData(mdsData);
        when(restClientService.get(anyString(), anyMap(), eq(GoldPriceResponse.class), anyInt(), anyBoolean()))
                .thenReturn(goldPriceResponse);

        // Mock PartyNameResponse for sender
        PartyNameResponse partyNameResponse = new PartyNameResponse();
        PartyNameResponse.Name name = new PartyNameResponse.Name();
        name.setLastName("Smith");
        name.setGivenName("John");
        name.setCustomerChristianName("J");
        partyNameResponse.setName(name);
        when(retrieveCustomerProfilesService.retrieveCustomerNamesWithCinNumber(anyString(), anyMap()))
                .thenReturn(partyNameResponse);

        // Mock duplicate key generation
        String mockUniqueKey = "unique-key-123";
        when(duplicateSubmitPreventionService.generateUniqueKey()).thenReturn(mockUniqueKey);

        // Mock the main POST call
        CreateTransferResponse mockResponse = new CreateTransferResponse();
        CreateTransferResponseData responseData = new CreateTransferResponseData();
        List<TransferOrderInfo> orderInfoList = new ArrayList<>();
        TransferOrderInfo orderInfo = new TransferOrderInfo();
        orderInfo.setRequestPriceValue(new BigDecimal("100"));
        orderInfoList.add(orderInfo);
        responseData.setTransferOrderLists(orderInfoList);
        mockResponse.setData(responseData);
        ResponseDetails responseDetails = new ResponseDetails();
        responseDetails.setResponseCodeNumber(0);
        mockResponse.setResponseDetails(responseDetails);
        when(restClientService.post(anyString(), anyMap(), any(), eq(CreateTransferResponse.class), anyInt(), anyBoolean()))
                .thenReturn(mockResponse);

        // Act
        CreateTransferResponse result = tradeTransferService.createTransfers(requestHeader, request);

        // Assert
        assertNotNull(result);
        assertEquals(mockUniqueKey, result.getData().getRequestUniqueKey());
        assertEquals(new BigDecimal("50.00"), result.getData().getTransferOrderLists().get(0).getRequestPriceValue());
        assertEquals("HKD", result.getData().getTransferOrderLists().get(0).getPriceCurrencyCode());
        assertEquals("2025-11-20T10:00:00Z", result.getData().getTransferOrderLists().get(0).getRequestPriceAsOfDateTime());
        assertEquals("Smith John J", result.getData().getSenderCustomerName()); // Full name set
        verify(sreValidationService).callSreForTransferValidation(eq("dac_tokenized_gold_transfer_sender_rule"), eq("dummy-cin"), eq("CUST001"), anyMap());
        verify(restClientService).post(anyString(), anyMap(), any(), eq(CreateTransferResponse.class), anyInt(), anyBoolean());
    }

    @Test
    void createTransfers_Success_COperation() {
        // Arrange
        Map<String, String> requestHeader = buildValidRequestHeader();
        CreateTransferRequest request = new CreateTransferRequest();
        CreateTransferRequestData data = new CreateTransferRequestData();
        data.setActionRequestCode(ActionRequestCode.C); // C operation, no gold price needed
        data.setSenderInvestmentAccountChecksumIdentifier("chk1");

        ReceiverInfo receiver = new ReceiverInfo();
        receiver.setTransferQuantity(new BigDecimal("100.00"));
        receiver.setReceiverCustomerNumber("CUST001");
        data.setReceiverLists(Collections.singletonList(receiver));
        request.setData(data);

        // Mock customer accounts
        CustomerAccounts customerAccounts = new CustomerAccounts();
        InvestmentAccount account = new InvestmentAccount();
        account.setChecksum("chk1");
        InvestmentAccountId accountId = new InvestmentAccountId();
        accountId.setAccountNumber("ACC123");
        account.setInvestmentAccountId(accountId);
        customerAccounts.setInvestmentAccountList(Collections.singletonList(account));

        when(restClientService.get(anyString(), any(), eq(CustomerAccounts.class), anyInt(), anyBoolean()))
                .thenReturn(customerAccounts);

        // Mock limit check
        RetrieveTransferLimitResponse currentLimit = new RetrieveTransferLimitResponse();
        RetrieveTransferLimitResponseData limitData = new RetrieveTransferLimitResponseData();
        limitData.setAvailableTodayAmount(new BigDecimal("1000"));
        currentLimit.setData(limitData);

        // Mock SRE validation
        RuleResponse sreResponse = new RuleResponse();
        ResponseDetails sreDetails = new ResponseDetails();
        sreDetails.setResponseCodeNumber(0);
        sreResponse.setResponseDetails(sreDetails);
        when(sreValidationService.callSreForTransferValidation(anyString(), anyString(), anyString(), anyMap()))
                .thenReturn(sreResponse);

        // Mock PartyNameResponse for sender
        PartyNameResponse partyNameResponse = new PartyNameResponse();
        PartyNameResponse.Name name = new PartyNameResponse.Name();
        name.setLastName("Smith");
        name.setGivenName("John");
        name.setCustomerChristianName("J");
        partyNameResponse.setName(name);
        when(retrieveCustomerProfilesService.retrieveCustomerNamesWithCinNumber(anyString(), anyMap()))
                .thenReturn(partyNameResponse);

        // Mock the main POST call
        CreateTransferResponse mockResponse = new CreateTransferResponse();
        CreateTransferResponseData responseData = new CreateTransferResponseData();
        List<TransferOrderInfo> orderInfoList = new ArrayList<>();
        TransferOrderInfo orderInfo = new TransferOrderInfo();
        orderInfo.setRequestPriceValue(new BigDecimal("100"));
        orderInfoList.add(orderInfo);
        responseData.setTransferOrderLists(orderInfoList);
        mockResponse.setData(responseData);
        ResponseDetails responseDetails = new ResponseDetails();
        responseDetails.setResponseCodeNumber(0);
        mockResponse.setResponseDetails(responseDetails);
        when(restClientService.post(anyString(), anyMap(), any(), eq(CreateTransferResponse.class), anyInt(), anyBoolean()))
                .thenReturn(mockResponse);

        // Act
        CreateTransferResponse result = tradeTransferService.createTransfers(requestHeader, request);

        // Assert
        assertNotNull(result);
        assertNull(result.getData().getRequestUniqueKey()); // Should not be set for C operation
        assertEquals(new BigDecimal("100"), result.getData().getTransferOrderLists().get(0).getRequestPriceValue()); // Should remain unchanged
        verify(sreValidationService).callSreForTransferValidation(eq("dac_tokenized_gold_transfer_sender_rule"), eq("dummy-cin"), eq("CUST001"), anyMap());
        verify(restClientService).post(anyString(), anyMap(), any(), eq(CreateTransferResponse.class), anyInt(), anyBoolean());
    }

    @Test
    void createTransfers_WhenDailyLimitExceeded_ThrowsTransferLimitExceededException() {
        // Arrange
        Map<String, String> requestHeader = buildValidRequestHeader();
        CreateTransferRequest request = new CreateTransferRequest();
        CreateTransferRequestData data = new CreateTransferRequestData();
        data.setActionRequestCode(ActionRequestCode.C);
        data.setSenderInvestmentAccountChecksumIdentifier("chk1");

        ReceiverInfo receiver = new ReceiverInfo();
        receiver.setTransferQuantity(new BigDecimal("1000")); // Total amount = 1000
        data.setReceiverLists(Collections.singletonList(receiver));
        request.setData(data);

        // Mock customer accounts
        CustomerAccounts customerAccounts = new CustomerAccounts();
        InvestmentAccount account = new InvestmentAccount();
        account.setChecksum("chk1");
        InvestmentAccountId accountId = new InvestmentAccountId();
        accountId.setAccountNumber("ACC123");
        account.setInvestmentAccountId(accountId);
        customerAccounts.setInvestmentAccountList(Collections.singletonList(account));

        when(restClientService.get(anyString(), any(), eq(CustomerAccounts.class), anyInt(), anyBoolean()))
                .thenReturn(customerAccounts);

        // Mock limit check - daily limit exceeded
        RetrieveTransferLimitResponse currentLimit = new RetrieveTransferLimitResponse();
        RetrieveTransferLimitResponseData limitData = new RetrieveTransferLimitResponseData();
        limitData.setAvailableTodayAmount(new BigDecimal("500")); // Less than 1000
        limitData.setMaxDailyLimitedAmount(new BigDecimal("1000"));
        currentLimit.setData(limitData);

        // Mock SRE validation
        RuleResponse sreResponse = new RuleResponse();
        ResponseDetails sreDetails = new ResponseDetails();
        sreDetails.setResponseCodeNumber(0);
        sreResponse.setResponseDetails(sreDetails);
        when(sreValidationService.callSreForTransferValidation(anyString(), anyString(), anyString(), anyMap()))
                .thenReturn(sreResponse);

        // Mock PartyNameResponse for sender
        PartyNameResponse partyNameResponse = new PartyNameResponse();
        PartyNameResponse.Name name = new PartyNameResponse.Name();
        name.setLastName("Smith");
        name.setGivenName("John");
        name.setCustomerChristianName("J");
        partyNameResponse.setName(name);
        when(retrieveCustomerProfilesService.retrieveCustomerNamesWithCinNumber(anyString(), anyMap()))
                .thenReturn(partyNameResponse);

        // Act & Assert
        assertThrows(TransferLimitExceededException.class, () -> {
            tradeTransferService.createTransfers(requestHeader, request);
        });
    }

    @Test
    void createTransfers_WhenSreValidationFails_ThrowsException() {
        // Arrange
        Map<String, String> requestHeader = buildValidRequestHeader();
        CreateTransferRequest request = new CreateTransferRequest();
        CreateTransferRequestData data = new CreateTransferRequestData();
        data.setActionRequestCode(ActionRequestCode.C);
        data.setSenderInvestmentAccountChecksumIdentifier("chk1");

        ReceiverInfo receiver = new ReceiverInfo();
        receiver.setTransferQuantity(new BigDecimal("100"));
        data.setReceiverLists(Collections.singletonList(receiver));
        request.setData(data);

        // Mock customer accounts
        CustomerAccounts customerAccounts = new CustomerAccounts();
        InvestmentAccount account = new InvestmentAccount();
        account.setChecksum("chk1");
        InvestmentAccountId accountId = new InvestmentAccountId();
        accountId.setAccountNumber("ACC123");
        account.setInvestmentAccountId(accountId);
        customerAccounts.setInvestmentAccountList(Collections.singletonList(account));

        when(restClientService.get(anyString(), any(), eq(CustomerAccounts.class), anyInt(), anyBoolean()))
                .thenReturn(customerAccounts);

        // Mock limit check
        RetrieveTransferLimitResponse currentLimit = new RetrieveTransferLimitResponse();
        RetrieveTransferLimitResponseData limitData = new RetrieveTransferLimitResponseData();
        limitData.setAvailableTodayAmount(new BigDecimal("1000"));
        currentLimit.setData(limitData);

        // Mock SRE validation to fail
        RuleResponse sreResponse = new RuleResponse();
        ResponseDetails sreDetails = new ResponseDetails();
        sreDetails.setResponseCodeNumber(100); // Non-zero code indicates failure
        sreResponse.setResponseDetails(sreDetails);
        when(sreValidationService.callSreForTransferValidation(anyString(), anyString(), anyString(), anyMap()))
                .thenReturn(sreResponse);

        // Mock PartyNameResponse for sender
        PartyNameResponse partyNameResponse = new PartyNameResponse();
        PartyNameResponse.Name name = new PartyNameResponse.Name();
        name.setLastName("Smith");
        name.setGivenName("John");
        name.setCustomerChristianName("J");
        partyNameResponse.setName(name);
        when(retrieveCustomerProfilesService.retrieveCustomerNamesWithCinNumber(anyString(), anyMap()))
                .thenReturn(partyNameResponse);

        // Act & Assert
        assertThrows(IllegalArgumentException.class, () -> {
            tradeTransferService.createTransfers(requestHeader, request);
        });
    }

    // ==================== modifyTransfers ====================

    @Test
    void modifyTransfers_Accept_Success() {
        // Arrange
        Map<String, String> requestHeader = buildValidRequestHeader();
        UpdateTransferRequest request = new UpdateTransferRequest();
        UpdateTransferRequestData data = new UpdateTransferRequestData();
        data.setTransferActionCode(TransferActionCode.A); // ACCEPT
        data.setReceiverInvestmentAccountChecksumIdentifier("chk1");

        request.setData(data);

        // Mock customer accounts for checksum -> account mapping
        CustomerAccounts customerAccounts = new CustomerAccounts();
        InvestmentAccount account = new InvestmentAccount();
        account.setChecksum("chk1");
        InvestmentAccountId accountId = new InvestmentAccountId();
        accountId.setAccountNumber("ACC123");
        account.setInvestmentAccountId(accountId);
        customerAccounts.setInvestmentAccountList(Collections.singletonList(account));

        when(restClientService.get(anyString(), any(), eq(CustomerAccounts.class), anyInt(), anyBoolean()))
                .thenReturn(customerAccounts);

        // Mock SRE validation for receiver
        RuleResponse sreResponse = new RuleResponse();
        ResponseDetails sreDetails = new ResponseDetails();
        sreDetails.setResponseCodeNumber(0);
        sreResponse.setResponseDetails(sreDetails);
        when(sreValidationService.callSreForTransferValidation(anyString(), anyString(), anyString(), anyMap()))
                .thenReturn(sreResponse);

        // Mock Gold Price for ACCEPT
        GoldPriceResponse goldPriceResponse = new GoldPriceResponse();
        GoldPriceResponseData mdsData = new GoldPriceResponseData();
        mdsData.setGoldPriceAmount(new BigDecimal("50.00"));
        mdsData.setPublishTime("2025-11-20T10:00:00Z");
        goldPriceResponse.setData(mdsData);
        when(restClientService.get(anyString(), anyMap(), eq(GoldPriceResponse.class), anyInt(), anyBoolean()))
                .thenReturn(goldPriceResponse);

        // Mock the main PUT call
        UpdateTransferResponse mockResponse = new UpdateTransferResponse();
        ResponseDetails responseDetails = new ResponseDetails();
        responseDetails.setResponseCodeNumber(0);
        mockResponse.setResponseDetails(responseDetails);
        when(restClientService.put(anyString(), anyMap(), any(), eq(UpdateTransferResponse.class), anyInt(), anyBoolean()))
                .thenReturn(mockResponse);

        // Act
        UpdateTransferResponse result = tradeTransferService.modifyTransfers(requestHeader, request);

        // Assert
        assertNotNull(result);
        assertEquals("chk1", request.getData().getReceiverInvestmentAccount().getAccountNumber()); // Account set
        assertEquals(new BigDecimal("50.00"), request.getData().getReceivePriceValue()); // Price set
        assertEquals("HKD", request.getData().getReceivePriceCurrencyCode()); // Currency set
        assertEquals("2025-11-20T10:00:00Z", request.getData().getReceivePriceAsOfDateTime()); // Time set
        verify(sreValidationService).callSreForTransferValidation(eq("dac_tokenized_gold_transfer_receiver_rule"), anyString(), eq("dummy-cin"), anyMap());
        verify(restClientService).put(anyString(), anyMap(), any(), eq(UpdateTransferResponse.class), anyInt(), anyBoolean());
    }

    @Test
    void modifyTransfers_Reject_Success() {
        // Arrange
        Map<String, String> requestHeader = buildValidRequestHeader();
        UpdateTransferRequest request = new UpdateTransferRequest();
        UpdateTransferRequestData data = new UpdateTransferRequestData();
        data.setTransferActionCode(TransferActionCode.R); // REJECT
        data.setReceiverInvestmentAccountChecksumIdentifier("chk1");

        request.setData(data);

        // Mock customer accounts for checksum -> account mapping
        CustomerAccounts customerAccounts = new CustomerAccounts();
        InvestmentAccount account = new InvestmentAccount();
        account.setChecksum("chk1");
        InvestmentAccountId accountId = new InvestmentAccountId();
        accountId.setAccountNumber("ACC123");
        account.setInvestmentAccountId(accountId);
        customerAccounts.setInvestmentAccountList(Collections.singletonList(account));

        when(restClientService.get(anyString(), any(), eq(CustomerAccounts.class), anyInt(), anyBoolean()))
                .thenReturn(customerAccounts);

        // Mock the main PUT call
        UpdateTransferResponse mockResponse = new UpdateTransferResponse();
        ResponseDetails responseDetails = new ResponseDetails();
        responseDetails.setResponseCodeNumber(0);
        mockResponse.setResponseDetails(responseDetails);
        when(restClientService.put(anyString(), anyMap(), any(), eq(UpdateTransferResponse.class), anyInt(), anyBoolean()))
                .thenReturn(mockResponse);

        // Act
        UpdateTransferResponse result = tradeTransferService.modifyTransfers(requestHeader, request);

        // Assert
        assertNotNull(result);
        assertEquals("chk1", request.getData().getReceiverInvestmentAccount().getAccountNumber()); // Account set
        assertNull(request.getData().getReceivePriceValue()); // Price NOT set for REJECT
        verify(sreValidationService, never()).callSreForTransferValidation(anyString(), anyString(), anyString(), anyMap()); // SRE not called for REJECT
        verify(restClientService).put(anyString(), anyMap(), any(), eq(UpdateTransferResponse.class), anyInt(), anyBoolean());
    }

    @Test
    void modifyTransfers_WhenSreValidationFailsForAccept_ThrowsException() {
        // Arrange
        Map<String, String> requestHeader = buildValidRequestHeader();
        UpdateTransferRequest request = new UpdateTransferRequest();
        UpdateTransferRequestData data = new UpdateTransferRequestData();
        data.setTransferActionCode(TransferActionCode.A); // ACCEPT
        data.setReceiverInvestmentAccountChecksumIdentifier("chk1");

        request.setData(data);

        // Mock customer accounts
        CustomerAccounts customerAccounts = new CustomerAccounts();
        InvestmentAccount account = new InvestmentAccount();
        account.setChecksum("chk1");
        InvestmentAccountId accountId = new InvestmentAccountId();
        accountId.setAccountNumber("ACC123");
        account.setInvestmentAccountId(accountId);
        customerAccounts.setInvestmentAccountList(Collections.singletonList(account));

        when(restClientService.get(anyString(), any(), eq(CustomerAccounts.class), anyInt(), anyBoolean()))
                .thenReturn(customerAccounts);

        // Mock SRE validation to fail
        RuleResponse sreResponse = new RuleResponse();
        ResponseDetails sreDetails = new ResponseDetails();
        sreDetails.setResponseCodeNumber(100); // Non-zero code indicates failure
        sreResponse.setResponseDetails(sreDetails);
        when(sreValidationService.callSreForTransferValidation(anyString(), anyString(), anyString(), anyMap()))
                .thenReturn(sreResponse);

        // Act & Assert
        assertThrows(IllegalArgumentException.class, () -> {
            tradeTransferService.modifyTransfers(requestHeader, request);
        });
    }

    // ==================== Private Method Tests ====================

    @Test
    void validateTransferLimits_WhenDailyLimitExceeded_ShouldThrowException() {
        // Arrange
        BigDecimal totalTranAmount = new BigDecimal("1000");
        RetrieveTransferLimitResponse currentLimit = new RetrieveTransferLimitResponse();
        RetrieveTransferLimitResponseData data = new RetrieveTransferLimitResponseData();
        data.setAvailableTodayAmount(new BigDecimal("500")); // Less than total amount
        data.setMaxDailyLimitedAmount(new BigDecimal("1000"));
        currentLimit.setData(data);

        // Act & Assert
        assertThrows(TransferLimitExceededException.class, () -> {
            tradeTransferService.validateTransferLimits(totalTranAmount, currentLimit);
        });
    }

    @Test
    void validateTransferLimits_WhenMonthlyLimitExceeded_ShouldThrowException() {
        // Arrange
        BigDecimal totalTranAmount = new BigDecimal("1000");
        RetrieveTransferLimitResponse currentLimit = new RetrieveTransferLimitResponse();
        RetrieveTransferLimitResponseData data = new RetrieveTransferLimitResponseData();
        data.setAvailableMonthToDateAmount(new BigDecimal("500")); // Less than total amount
        data.setMaxMonthlyLimitedAmount(new BigDecimal("1000"));
        currentLimit.setData(data);

        // Act & Assert
        assertThrows(TransferLimitExceededException.class, () -> {
            tradeTransferService.validateTransferLimits(totalTranAmount, currentLimit);
        });
    }

    @Test
    void validateTransferLimits_WhenYearlyLimitExceeded_ShouldThrowException() {
        // Arrange
        BigDecimal totalTranAmount = new BigDecimal("1000");
        RetrieveTransferLimitResponse currentLimit = new RetrieveTransferLimitResponse();
        RetrieveTransferLimitResponseData data = new RetrieveTransferLimitResponseData();
        data.setAvailableYearToDateAmount(new BigDecimal("500")); // Less than total amount
        data.setMaxYearlyLimitedAmount(new BigDecimal("1000"));
        currentLimit.setData(data);

        // Act & Assert
        assertThrows(TransferLimitExceededException.class, () -> {
            tradeTransferService.validateTransferLimits(totalTranAmount, currentLimit);
        });
    }

    @Test
    void validateTransferLimits_WhenAllLimitsAreSufficient_ShouldNotThrowException() {
        // Arrange
        BigDecimal totalTranAmount = new BigDecimal("500");
        RetrieveTransferLimitResponse currentLimit = new RetrieveTransferLimitResponse();
        RetrieveTransferLimitResponseData data = new RetrieveTransferLimitResponseData();
        data.setAvailableTodayAmount(new BigDecimal("1000"));
        data.setAvailableMonthToDateAmount(new BigDecimal("1000"));
        data.setAvailableYearToDateAmount(new BigDecimal("1000"));
        currentLimit.setData(data);

        // Act & Assert
        assertDoesNotThrow(() -> {
            tradeTransferService.validateTransferLimits(totalTranAmount, currentLimit);
        });
    }

    @Test
    void handleDOperationResponse_WhenActionIsD_ShouldSetRequestUniqueKeyAndPrice() {
        // Arrange
        CreateTransferRequest createTransferRequest = new CreateTransferRequest();
        CreateTransferRequestData data = new CreateTransferRequestData();
        data.setActionRequestCode(ActionRequestCode.D); // D operation
        createTransferRequest.setData(data);

        CreateTransferResponse createTransferResponse = new CreateTransferResponse();
        CreateTransferResponseData responseData = new CreateTransferResponseData();
        List<TransferOrderInfo> orderInfoList = new ArrayList<>();
        TransferOrderInfo orderInfo = new TransferOrderInfo();
        orderInfo.setRequestPriceValue(new BigDecimal("100"));
        orderInfoList.add(orderInfo);
        responseData.setTransferOrderLists(orderInfoList);
        createTransferResponse.setData(responseData);

        GoldPriceResponse goldPriceResponse = new GoldPriceResponse();
        GoldPriceResponseData mdsData = new GoldPriceResponseData();
        mdsData.setGoldPriceAmount(new BigDecimal("1000"));
        mdsData.setPublishTime("2025-11-20T10:00:00Z");
        goldPriceResponse.setData(mdsData);

        // Mock the duplicateSubmitPreventionService to return a unique key
        String mockUniqueKey = "unique-key-123";
        when(duplicateSubmitPreventionService.generateUniqueKey()).thenReturn(mockUniqueKey);

        // Act
        tradeTransferService.handleDOperationResponse(createTransferRequest, createTransferResponse, goldPriceResponse);

        // Assert
        assertNotNull(createTransferResponse.getData().getRequestUniqueKey());
        assertEquals(mockUniqueKey, createTransferResponse.getData().getRequestUniqueKey());
        assertEquals(new BigDecimal("1000"), createTransferResponse.getData().getTransferOrderLists().get(0).getRequestPriceValue());
        assertEquals("HKD", createTransferResponse.getData().getTransferOrderLists().get(0).getPriceCurrencyCode());
        assertEquals("2025-11-20T10:00:00Z", createTransferResponse.getData().getTransferOrderLists().get(0).getRequestPriceAsOfDateTime());
    }

    @Test
    void handleDOperationResponse_WhenActionIsNotD_ShouldNotModifyResponse() {
        // Arrange
        CreateTransferRequest createTransferRequest = new CreateTransferRequest();
        CreateTransferRequestData data = new CreateTransferRequestData();
        data.setActionRequestCode(ActionRequestCode.C); // Not D operation
        createTransferRequest.setData(data);

        CreateTransferResponse createTransferResponse = new CreateTransferResponse();
        CreateTransferResponseData responseData = new CreateTransferResponseData();
        List<TransferOrderInfo> orderInfoList = new ArrayList<>();
        TransferOrderInfo orderInfo = new TransferOrderInfo();
        orderInfo.setRequestPriceValue(new BigDecimal("100"));
        orderInfoList.add(orderInfo);
        responseData.setTransferOrderLists(orderInfoList);
        createTransferResponse.setData(responseData);

        GoldPriceResponse goldPriceResponse = new GoldPriceResponse();
        GoldPriceResponseData mdsData = new GoldPriceResponseData();
        mdsData.setGoldPriceAmount(new BigDecimal("1000"));
        mdsData.setPublishTime("2025-11-20T10:00:00Z");
        goldPriceResponse.setData(mdsData);

        // Act
        tradeTransferService.handleDOperationResponse(createTransferRequest, createTransferResponse, goldPriceResponse);

        // Assert
        assertNull(createTransferResponse.getData().getRequestUniqueKey()); // Should not be set
        assertEquals(new BigDecimal("100"), createTransferResponse.getData().getTransferOrderLists().get(0).getRequestPriceValue()); // Should remain unchanged
        assertEquals("HKD", createTransferResponse.getData().getTransferOrderLists().get(0).getPriceCurrencyCode()); // Should remain unchanged
        assertEquals("2025-11-20T10:00:00Z", createTransferResponse.getData().getTransferOrderLists().get(0).getRequestPriceAsOfDateTime()); // Should remain unchanged
    }

    @Test
    void findAccountChecksumForAccountNumber_WhenAccountExists_ShouldReturnChecksum() {
        // Arrange
        CustomerAccounts customerAccounts = new CustomerAccounts();
        InvestmentAccount account = new InvestmentAccount();
        account.setChecksum("checksum-123");
        InvestmentAccountId accountId = new InvestmentAccountId();
        accountId.setAccountNumber("123456");
        account.setInvestmentAccountId(accountId);
        customerAccounts.setInvestmentAccountList(Collections.singletonList(account));

        // Act
        String result = tradeTransferService.findAccountChecksumForAccountNumber(customerAccounts, "123456");

        // Assert
        assertEquals("checksum-123", result);
    }

    @Test
    void findAccountChecksumForAccountNumber_WhenAccountDoesNotExist_ShouldReturnNull() {
        // Arrange
        CustomerAccounts customerAccounts = new CustomerAccounts();
        InvestmentAccount account = new InvestmentAccount();
        account.setChecksum("checksum-123");
        InvestmentAccountId accountId = new InvestmentAccountId();
        accountId.setAccountNumber("123456");
        account.setInvestmentAccountId(accountId);
        customerAccounts.setInvestmentAccountList(Collections.singletonList(account));

        // Act
        String result = tradeTransferService.findAccountChecksumForAccountNumber(customerAccounts, "999999");

        // Assert
        assertNull(result);
    }

    @Test
    void findAccountChecksumForAccountNumber_WhenCustomerAccountsIsNull_ShouldReturnNull() {
        // Arrange
        CustomerAccounts customerAccounts = null;

        // Act
        String result = tradeTransferService.findAccountChecksumForAccountNumber(customerAccounts, "123456");

        // Assert
        assertNull(result);
    }

    @Test
    void maskNamesInResponse_RetrieveTransferListResponseData_WhenSenderAndReceiverBankCustomer_ShouldMaskNames() {
        // Arrange
        RetrieveTransferListResponseData responseData = new RetrieveTransferListResponseData();
        List<TransferListItemInfo> transferLists = new ArrayList<>();

        // Sender side with isReceiverBankCustomer = "Y" -> Mask sender names
        TransferListItemInfo senderItem = new TransferListItemInfo();
        senderItem.setTransferSideCode(TransferSideCode.SENDER);
        senderItem.setIsReceiverBankCustomer("Y");
        senderItem.setSenderCustomerFirstName("John");
        senderItem.setSenderCustomerMiddleName("A");
        transferLists.add(senderItem);

        // Receiver side -> Mask sender names (as receiver is bank customer)
        TransferListItemInfo receiverItem = new TransferListItemInfo();
        receiverItem.setTransferSideCode(TransferSideCode.RECEIVER);
        receiverItem.setSenderCustomerFirstName("Jane");
        receiverItem.setSenderCustomerMiddleName("B");
        transferLists.add(receiverItem);

        responseData.setTransferLists(transferLists);

        // Act
        tradeTransferService.maskNamesInResponse(responseData);

        // Assert
        assertEquals("J****n", responseData.getTransferLists().get(0).getSenderCustomerFirstName());
        assertEquals("A***", responseData.getTransferLists().get(0).getSenderCustomerMiddleName());
        assertEquals("J****e", responseData.getTransferLists().get(1).getSenderCustomerFirstName());
        assertEquals("B***", responseData.getTransferLists().get(1).getSenderCustomerMiddleName());
    }

    @Test
    void maskNamesInResponse_RetrieveTransferDetailResponseData_WhenSenderAndReceiverBankCustomer_ShouldMaskNames() {
        // Arrange
        RetrieveTransferDetailResponseData responseData = new RetrieveTransferDetailResponseData();
        responseData.setTransferSideCode(TransferSideCode.SENDER);
        responseData.setIsReceiverBankCustomer("Y");
        responseData.setSenderCustomerFirstName("John");
        responseData.setSenderCustomerMiddleName("A");

        // Act
        tradeTransferService.maskNamesInResponse(responseData);

        // Assert
        assertEquals("J****n", responseData.getSenderCustomerFirstName());
        assertEquals("A***", responseData.getSenderCustomerMiddleName());
    }

    @Test
    void maskNamesInResponse_RetrieveTransferDetailResponseData_WhenReceiverAndNotBankCustomer_ShouldNotMaskNames() {
        // Arrange
        RetrieveTransferDetailResponseData responseData = new RetrieveTransferDetailResponseData();
        responseData.setTransferSideCode(TransferSideCode.RECEIVER);
        responseData.setIsReceiverBankCustomer("N");
        responseData.setSenderCustomerFirstName("John");
        responseData.setSenderCustomerMiddleName("A");

        // Act
        tradeTransferService.maskNamesInResponse(responseData);

        // Assert
        assertEquals("John", responseData.getSenderCustomerFirstName());
        assertEquals("A", responseData.getSenderCustomerMiddleName());
    }

    @Test
    void maskNamesInResponse_RetrieveTransferDetailResponseData_WhenSenderAndNotReceiverBankCustomer_ShouldNotMaskNames() {
        // Arrange
        RetrieveTransferDetailResponseData responseData = new RetrieveTransferDetailResponseData();
        responseData.setTransferSideCode(TransferSideCode.SENDER);
        responseData.setIsReceiverBankCustomer("N"); // Not bank customer
        responseData.setSenderCustomerFirstName("John");
        responseData.setSenderCustomerMiddleName("A");

        // Act
        tradeTransferService.maskNamesInResponse(responseData);

        // Assert
        assertEquals("John", responseData.getSenderCustomerFirstName());
        assertEquals("A", responseData.getSenderCustomerMiddleName());
    }

    // ==================== Helper Methods ====================

    private Map<String, String> buildValidRequestHeader() {
        Map<String, String> header = new HashMap<>();
        header.put(HTTPRequestHeaderConstants.X_HSBC_CHNL_COUNTRYCODE, "HK");
        header.put(HTTPRequestHeaderConstants.X_HSBC_CHNL_GROUP_MEMBER, "HBAP");
        header.put(HTTPRequestHeaderConstants.X_HSBC_SAML, dummyToken);
        header.put(HTTPRequestHeaderConstants.X_HSBC_SAML3, dummyToken);
        header.put(HTTPRequestHeaderConstants.X_HSBC_CUSTOMER_ID, "dummy-cin");
        return header;
    }
}
